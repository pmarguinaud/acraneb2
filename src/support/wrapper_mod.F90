MODULE WRAPPER_MOD

USE PARKIND1

IMPLICIT NONE

INTERFACE WR

  MODULE PROCEDURE WR1, WR2, WR3

END INTERFACE

CONTAINS

SUBROUTINE WRAPPER(KLON,KLEV,KGPBLK,KCOUNT,LCHECK,LSAVE)

USE MODEL_PHYSICS_MF_MOD , ONLY : MODEL_PHYSICS_MF_TYPE
USE PARKIND1 ,ONLY : JPIM     ,JPRB

USE YOMRIP   ,ONLY : TRIP
USE YOERDI   ,ONLY : TERDI

USE PREPARE_ACRANEB2_MOD
USE CHECK_ACRANEB2_MOD
USE STACK_MOD

use omp_lib

IMPLICIT NONE

! arguments
INTEGER(KIND=JPIM), INTENT(IN) :: KLON
INTEGER(KIND=JPIM), INTENT(IN) :: KLEV
INTEGER(KIND=JPIM), INTENT(IN) :: KGPBLK
INTEGER(KIND=JPIM), INTENT(IN) :: KCOUNT
LOGICAL, INTENT(IN) :: LCHECK, LSAVE

#include "acraneb2.intfb.h"

! acraneb arguments
TYPE(TERDI)        :: YDERDI
TYPE(MODEL_PHYSICS_MF_TYPE) :: YDML_PHY_MF
TYPE(TRIP)         :: YDRIP
INTEGER(KIND=JPIM) :: KIDIA 
INTEGER(KIND=JPIM) :: KFDIA 
INTEGER(KIND=JPIM) :: KTDIA 
INTEGER(KIND=JPIM) :: KJN
INTEGER(KIND=JPIM) :: KSTEP
REAL(KIND=JPRB) :: PAPRS(KLON,0:KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PAPRSF(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PCP(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PR(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PDELP(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PNEB(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PQ(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PQCO2(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PQICE(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PQLI(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PQO3(KLON,0:KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PT(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PALB(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PALBDIR(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PEMIS(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PGELAM(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PGEMU(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PMU0(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PMU0LU(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PTS(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PDECRD(KLON,KGPBLK)
REAL(KIND=JPRB) :: PCLCT(KLON,KGPBLK)
REAL(KIND=JPRB) :: PGDEOSI(KLON,0:KLEV,2,KGPBLK)
REAL(KIND=JPRB) :: PGUEOSI(KLON,0:KLEV,2,KGPBLK)
REAL(KIND=JPRB) :: PGMU0(KLON,0:0,KGPBLK)
REAL(KIND=JPRB) :: PGMU0_MIN(KLON,KGPBLK)
REAL(KIND=JPRB) :: PGMU0_MAX(KLON,KGPBLK)
REAL(KIND=JPRB) :: PGDEOTI(KLON,0:KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGDEOTI2(KLON,0:KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGUEOTI(KLON,0:KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGUEOTI2(KLON,0:KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGEOLT(KLON,KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGEOXT(KLON,KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGRPROX(KLON,0:KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGMIXP(KLON,0:KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGFLUXC(KLON,0:KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGRSURF(KLON,KGPBLK)
REAL(KIND=JPRB) :: PSDUR(KLON,KGPBLK)
REAL(KIND=JPRB) :: PFRSO(KLON,0:KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PFRTH(KLON,0:KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PFRSODS(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PFRSOPS(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PFRSOLU(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PFRTHDS(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PDAER(KLON,KLEV,6,KGPBLK) 
REAL(KIND=JPRB), ALLOCATABLE :: PSTACK(:,:)
INTEGER(KIND=8) :: ISTSZ

TYPE (STACK) :: YLSTACK

real(kind=8) :: ts,te
REAL(KIND=8) :: TSC, TEC, TSD, TED, ZTC, ZTD

INTEGER :: JCOUNT, JBLK, JLON
INTEGER :: ITID, JBLK1, JBLK2
INTEGER :: NTID
INTEGER :: IRANK, ISIZE

#ifdef USE_OPENMP
IRANK = 0
ISIZE = 1

CALL LINUX_BIND (IRANK, ISIZE)
CALL LINUX_BIND_DUMP (IRANK, ISIZE)
#endif

IF (.FALSE.) THEN
#ifdef USE_OPENMP
!$OMP PARALLEL PRIVATE (ITID, JBLK1, JBLK2)

NTID = OMP_GET_MAX_THREADS ()
ITID = OMP_GET_THREAD_NUM ()
JBLK1 = 1 +  (KGPBLK * (ITID+0)) / NTID
JBLK2 =      (KGPBLK * (ITID+1)) / NTID

! Binding with first touch

DO JBLK=JBLK1,JBLK2
  PAPRS      (:,:,JBLK)          = 0.0_JPRB
  PAPRSF     (:,:,JBLK)          = 0.0_JPRB
  PCP        (:,:,JBLK)          = 0.0_JPRB
  PR         (:,:,JBLK)          = 0.0_JPRB
  PDELP      (:,:,JBLK)          = 0.0_JPRB
  PNEB       (:,:,JBLK)          = 0.0_JPRB
  PQ         (:,:,JBLK)          = 0.0_JPRB
  PQCO2      (:,:,JBLK)          = 0.0_JPRB
  PQICE      (:,:,JBLK)          = 0.0_JPRB
  PQLI       (:,:,JBLK)          = 0.0_JPRB
  PQO3       (:,:,JBLK)          = 0.0_JPRB
  PT         (:,:,JBLK)          = 0.0_JPRB
  PALB       (:,JBLK)            = 0.0_JPRB
  PALBDIR    (:,JBLK)            = 0.0_JPRB
  PEMIS      (:,JBLK)            = 0.0_JPRB
  PGELAM     (:,JBLK)            = 0.0_JPRB
  PGEMU      (:,JBLK)            = 0.0_JPRB
  PMU0       (:,JBLK)            = 0.0_JPRB
  PMU0LU     (:,JBLK)            = 0.0_JPRB
  PTS        (:,JBLK)            = 0.0_JPRB
  PDECRD     (:,JBLK)            = 0.0_JPRB
  PCLCT      (:,JBLK)            = 0.0_JPRB
  PGDEOSI    (:,:,:,JBLK)        = 0.0_JPRB
  PGUEOSI    (:,:,:,JBLK)        = 0.0_JPRB
  PGMU0      (:,:,JBLK)          = 0.0_JPRB
  PGMU0_MIN  (:,JBLK)            = 0.0_JPRB
  PGMU0_MAX  (:,JBLK)            = 0.0_JPRB
  PGDEOTI    (:,:,JBLK)          = 0.0_JPRB
  PGDEOTI2   (:,:,JBLK)          = 0.0_JPRB
  PGUEOTI    (:,:,JBLK)          = 0.0_JPRB
  PGUEOTI2   (:,:,JBLK)          = 0.0_JPRB
  PGEOLT     (:,:,JBLK)          = 0.0_JPRB
  PGEOXT     (:,:,JBLK)          = 0.0_JPRB
  PGRPROX    (:,:,JBLK)          = 0.0_JPRB
  PGMIXP     (:,:,JBLK)          = 0.0_JPRB
  PGFLUXC    (:,:,JBLK)          = 0.0_JPRB
  PGRSURF    (:,JBLK)            = 0.0_JPRB
  PSDUR      (:,JBLK)            = 0.0_JPRB
  PFRSO      (:,:,JBLK)          = 0.0_JPRB
  PFRTH      (:,:,JBLK)          = 0.0_JPRB
  PFRSODS    (:,JBLK)            = 0.0_JPRB
  PFRSOPS    (:,JBLK)            = 0.0_JPRB
  PFRSOLU    (:,JBLK)            = 0.0_JPRB
  PFRTHDS    (:,JBLK)            = 0.0_JPRB
  PDAER      (:,:,:,JBLK)        = 0.0_JPRB
ENDDO

!$OMP END PARALLEL 
#endif

ENDIF


CALL PREPARE_ACRANEB2(YDERDI,YDRIP,YDML_PHY_MF,KIDIA,KFDIA,KLON,KTDIA,KLEV,KJN,KSTEP, &
 & KGPBLK, &
 & PAPRS,PAPRSF,PCP,PR,PDELP,PNEB,PQ,PQCO2,PQICE,PQLI,PQO3,PT, &
 & PALB,PALBDIR,PEMIS,PGELAM,PGEMU,PMU0,PMU0LU,PTS,PDECRD,PCLCT, &
 & PGDEOSI,PGUEOSI,PGMU0,PGMU0_MIN,PGMU0_MAX, &
 & PGDEOTI,PGDEOTI2,PGUEOTI,PGUEOTI2,PGEOLT,PGEOXT, &
 & PGRPROX,PGMIXP,PGFLUXC,PGRSURF,PSDUR, &
 & PFRSO,PFRTH, &
 & PFRSODS,PFRSOPS,PFRSOLU,PFRTHDS, &
 & PDAER)

ISTSZ = 51000*KLON
ALLOCATE (PSTACK (ISTSZ, KGPBLK))

ts=omp_get_wtime()

ZTD = 0.
ZTC = 0.

DO JCOUNT=1,KCOUNT


    TSD = OMP_GET_WTIME ()

!$acc data &
!$acc   copyin  (YDERDI,YDRIP,YDML_PHY_MF,PAPRS,PAPRSF,PCP,PR,PDELP,PNEB,PQ,PQCO2,PQICE,PQLI,PQO3,PT, &
!$acc            PALB,PALBDIR,PEMIS,PGELAM,PGEMU,PMU0,PMU0LU,PTS,PDECRD,PCLCT,PDAER) &
!$acc   copy    (PGDEOSI,PGUEOSI,PGMU0,PGMU0_MIN,PGMU0_MAX, &
!$acc            PGDEOTI,PGDEOTI2,PGUEOTI,PGUEOTI2,PGEOLT,PGEOXT, &
!$acc            PGRPROX,PGMIXP,PGFLUXC,PGRSURF,PSDUR) &
!$acc   copyout (PFRSO,PFRTH,PFRSODS,PFRSOPS,PFRSOLU,PFRTHDS) &
!$acc   create (PSTACK)

    TSC = OMP_GET_WTIME ()

#ifdef USE_OPENMP
!$OMP PARALLEL PRIVATE (KIDIA, KFDIA, ITID, JBLK1, JBLK2)
#endif

#ifdef _OPENACC
JBLK1 = 1
JBLK2 = KGPBLK
#endif

#ifdef USE_OPENMP
NTID = OMP_GET_MAX_THREADS ()
ITID = OMP_GET_THREAD_NUM ()
JBLK1 = 1 +  (KGPBLK * (ITID+0)) / NTID
JBLK2 =      (KGPBLK * (ITID+1)) / NTID
#endif

!$acc parallel loop gang vector private (YLSTACK,KIDIA,KFDIA) collapse (2)
DO JBLK=JBLK1,JBLK2

#ifdef _OPENACC
  DO JLON = 1, KLON
  KIDIA = JLON
  KFDIA = JLON
#endif

#ifdef USE_OPENMP
  KIDIA = 1
  KFDIA = KLON
#endif

#ifdef USE_STACK
  YLSTACK%L = LOC (PSTACK (1, JBLK))
  YLSTACK%U = YLSTACK%L + ISTSZ * 8 
#endif

  CALL ACRANEB2( &
   & YDERDI,YDRIP,YDML_PHY_MF,KIDIA,KFDIA,KLON,KTDIA,KLEV,KJN,KSTEP, &
  ! - INPUT 2D
   & PAPRS(:,:,JBLK),PAPRSF(:,:,JBLK),PCP(:,:,JBLK),PR(:,:,JBLK),PDELP(:,:,JBLK),PNEB(:,:,JBLK), &
   & PQ(:,:,JBLK),PQCO2(:,:,JBLK),PQICE(:,:,JBLK),PQLI(:,:,JBLK),PQO3(:,:,JBLK),PT(:,:,JBLK), &
  ! - INPUT 1D
   & PALB(:,JBLK),PALBDIR(:,JBLK),PEMIS(:,JBLK),PGELAM(:,JBLK), &
   & PGEMU(:,JBLK),PMU0(:,JBLK),PMU0LU(:,JBLK),PTS(:,JBLK),PDECRD(:,JBLK),PCLCT(:,JBLK), &
  ! - INPUT/OUTPUT
   & PGDEOSI(:,:,:,JBLK),PGUEOSI(:,:,:,JBLK),PGMU0(:,:,JBLK),PGMU0_MIN(:,JBLK),PGMU0_MAX(:,JBLK), &
   & PGDEOTI(:,:,JBLK),PGDEOTI2(:,:,JBLK),PGUEOTI(:,:,JBLK),PGUEOTI2(:,:,JBLK),PGEOLT(:,:,JBLK),PGEOXT(:,:,JBLK), &
   & PGRPROX(:,:,JBLK),PGMIXP(:,:,JBLK),PGFLUXC(:,:,JBLK),PGRSURF(:,JBLK),PSDUR(:,JBLK), &
  ! - OUTPUT 2D
   & PFRSO(:,:,JBLK),PFRTH(:,:,JBLK), &
  ! - OUTPUT 1D
   & PFRSODS(:,JBLK),PFRSOPS(:,JBLK),PFRSOLU(:,JBLK),PFRTHDS(:,JBLK), &
  ! - INPUT 2D x 6
   & PDAER(:,:,:,JBLK) &
#ifdef USE_STACK
   & , YLSTACK &
#endif
   & )

#ifdef _OPENACC
  ENDDO
#endif

ENDDO
!$acc end parallel loop

#ifdef USE_OPENMP
!$OMP END PARALLEL 
#endif

    TEC = OMP_GET_WTIME ()

!$acc end data

    TED = OMP_GET_WTIME ()

    ZTC = ZTC + (TEC - TSC)
    ZTD = ZTD + (TED - TSD)

ENDDO

te=omp_get_wtime()
write (*,'(A,F8.2,A)') 'elapsed time : ',te-ts,' s'
write (*,'(A,F8.4,A)') '          i.e. ',1000.*(te-ts)/(KLON*KGPBLK)/KCOUNT,' ms/gp'

PRINT *, " ZTD = ", ZTD, ZTD / REAL (KLON*KGPBLK*KCOUNT, JPRB)
PRINT *, " ZTC = ", ZTC, ZTC / REAL (KLON*KGPBLK*KCOUNT, JPRB)


! check output
IF ( LCHECK ) THEN
	CALL CHECK_ACRANEB2(KLON,KLEV, KGPBLK, &
	 & PFRSO,PFRTH, &
	 & PFRSODS,PFRSOPS,PFRSOLU,PFRTHDS)
ENDIF

IF (LSAVE) THEN
CALL WR ('PFRSO.dat',   PFRSO)
CALL WR ('PFRTH.dat',   PFRTH)
CALL WR ('PFRSODS.dat', PFRSODS)
CALL WR ('PFRSOPS.dat', PFRSOPS)
CALL WR ('PFRSOLU.dat', PFRSOLU)
CALL WR ('PFRTHDS.dat', PFRTHDS)
ENDIF

END SUBROUTINE WRAPPER

SUBROUTINE WR1 (CDFILE, P1)

CHARACTER (LEN=*) :: CDFILE
REAL(KIND=JPRB)   :: P1 (:)

INTEGER :: J1

OPEN (77, FILE=TRIM (CDFILE), FORM="FORMATTED")

DO J1 = 1, SIZE (P1, 1)
WRITE (77, '(I5,E25.17)') J1, P1 (J1)
ENDDO

CLOSE (77)

END SUBROUTINE

SUBROUTINE WR2 (CDFILE, P2)

CHARACTER (LEN=*) :: CDFILE
REAL(KIND=JPRB)   :: P2 (:,:)

INTEGER :: J1, J2

OPEN (77, FILE=TRIM (CDFILE), FORM="FORMATTED")

DO J1 = 1, SIZE (P2, 1)
DO J2 = 1, SIZE (P2, 2)
WRITE (77, '(I5,I5,E25.17)') J1, J2, P2 (J1, J2)
ENDDO
ENDDO

CLOSE (77)

END SUBROUTINE

SUBROUTINE WR3 (CDFILE, P3)

CHARACTER (LEN=*) :: CDFILE
REAL(KIND=JPRB)   :: P3 (:,:,:)

INTEGER :: J1, J2, J3

OPEN (77, FILE=TRIM (CDFILE), FORM="FORMATTED")

DO J1 = 1, SIZE (P3, 1)
DO J2 = 1, SIZE (P3, 2)
DO J3 = 1, SIZE (P3, 3)
WRITE (77, '(I5,I5,I5,E25.17)') J1, J2, J3, P3 (J1, J2, J3)
ENDDO
ENDDO
ENDDO

CLOSE (77)

END SUBROUTINE

END MODULE WRAPPER_MOD
