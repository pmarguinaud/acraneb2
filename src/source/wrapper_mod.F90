MODULE WRAPPER_MOD

USE PARKIND1

IMPLICIT NONE

CONTAINS

SUBROUTINE WRAPPER(KLON,KLEV,KGPBLK,KCOUNT,LCHECK,LSAVE)

USE MODEL_PHYSICS_MF_MOD , ONLY : MODEL_PHYSICS_MF_TYPE
USE PARKIND1 ,ONLY : JPIM     ,JPRB

USE YOMRIP   ,ONLY : TRIP
USE YOERDI   ,ONLY : TERDI

USE PREPARE_ACRANEB2_MOD
USE CHECK_ACRANEB2_MOD
USE STACK_MOD

use omp_lib

IMPLICIT NONE

! arguments
INTEGER(KIND=JPIM), INTENT(IN) :: KLON
INTEGER(KIND=JPIM), INTENT(IN) :: KLEV
INTEGER(KIND=JPIM), INTENT(IN) :: KGPBLK
INTEGER(KIND=JPIM), INTENT(IN) :: KCOUNT
LOGICAL, INTENT(IN) :: LCHECK, LSAVE

#include "acraneb2.intfb.h"

! acraneb arguments
TYPE(TERDI)        :: YDERDI
TYPE(MODEL_PHYSICS_MF_TYPE) :: YDML_PHY_MF
TYPE(TRIP)         :: YDRIP
INTEGER(KIND=JPIM) :: KIDIA 
INTEGER(KIND=JPIM) :: KFDIA 
INTEGER(KIND=JPIM) :: KTDIA 
INTEGER(KIND=JPIM) :: KJN
INTEGER(KIND=JPIM) :: KSTEP
REAL(KIND=JPRB) :: PAPRS(KLON,0:KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PAPRSF(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PCP(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PR(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PDELP(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PNEB(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PQ(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PQCO2(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PQICE(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PQLI(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PQO3(KLON,0:KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PT(KLON,KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PALB(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PALBDIR(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PEMIS(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PGELAM(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PGEMU(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PMU0(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PMU0LU(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PTS(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PDECRD(KLON,KGPBLK)
REAL(KIND=JPRB) :: PCLCT(KLON,KGPBLK)
REAL(KIND=JPRB) :: PGDEOSI(KLON,0:KLEV,2,KGPBLK)
REAL(KIND=JPRB) :: PGUEOSI(KLON,0:KLEV,2,KGPBLK)
REAL(KIND=JPRB) :: PGMU0(KLON,0:0,KGPBLK)
REAL(KIND=JPRB) :: PGMU0_MIN(KLON,KGPBLK)
REAL(KIND=JPRB) :: PGMU0_MAX(KLON,KGPBLK)
REAL(KIND=JPRB) :: PGDEOTI(KLON,0:KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGDEOTI2(KLON,0:KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGUEOTI(KLON,0:KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGUEOTI2(KLON,0:KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGEOLT(KLON,KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGEOXT(KLON,KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGRPROX(KLON,0:KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGMIXP(KLON,0:KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGFLUXC(KLON,0:KLEV,KGPBLK)
REAL(KIND=JPRB) :: PGRSURF(KLON,KGPBLK)
REAL(KIND=JPRB) :: PSDUR(KLON,KGPBLK)
REAL(KIND=JPRB) :: PFRSO(KLON,0:KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PFRTH(KLON,0:KLEV,KGPBLK) 
REAL(KIND=JPRB) :: PFRSODS(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PFRSOPS(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PFRSOLU(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PFRTHDS(KLON,KGPBLK) 
REAL(KIND=JPRB) :: PDAER(KLON,KLEV,6,KGPBLK) 
REAL(KIND=JPRB), ALLOCATABLE :: PSTACK(:,:)
INTEGER(KIND=8) :: ISTSZ

TYPE (STACK) :: YLSTACK

real(kind=8) :: ts,te
REAL(KIND=8) :: TSC, TEC, TSD, TED, ZTC, ZTD

INTEGER :: JCOUNT, JBLK, JLON
INTEGER :: ITID, JBLK1, JBLK2
INTEGER :: NTID
INTEGER :: IRANK, ISIZE

#ifdef USE_OPENMP
IRANK = 0
ISIZE = 1

CALL LINUX_BIND (IRANK, ISIZE)
CALL LINUX_BIND_DUMP (IRANK, ISIZE)
#endif

IF (.FALSE.) THEN
#ifdef USE_OPENMP
!$OMP PARALLEL PRIVATE (ITID, JBLK1, JBLK2)

NTID = OMP_GET_MAX_THREADS ()
ITID = OMP_GET_THREAD_NUM ()
JBLK1 = 1 +  (KGPBLK * (ITID+0)) / NTID
JBLK2 =      (KGPBLK * (ITID+1)) / NTID

! Binding with first touch

DO JBLK=JBLK1,JBLK2
  PAPRS      (:,:,JBLK)          = 0.0_JPRB
  PAPRSF     (:,:,JBLK)          = 0.0_JPRB
  PCP        (:,:,JBLK)          = 0.0_JPRB
  PR         (:,:,JBLK)          = 0.0_JPRB
  PDELP      (:,:,JBLK)          = 0.0_JPRB
  PNEB       (:,:,JBLK)          = 0.0_JPRB
  PQ         (:,:,JBLK)          = 0.0_JPRB
  PQCO2      (:,:,JBLK)          = 0.0_JPRB
  PQICE      (:,:,JBLK)          = 0.0_JPRB
  PQLI       (:,:,JBLK)          = 0.0_JPRB
  PQO3       (:,:,JBLK)          = 0.0_JPRB
  PT         (:,:,JBLK)          = 0.0_JPRB
  PALB       (:,JBLK)            = 0.0_JPRB
  PALBDIR    (:,JBLK)            = 0.0_JPRB
  PEMIS      (:,JBLK)            = 0.0_JPRB
  PGELAM     (:,JBLK)            = 0.0_JPRB
  PGEMU      (:,JBLK)            = 0.0_JPRB
  PMU0       (:,JBLK)            = 0.0_JPRB
  PMU0LU     (:,JBLK)            = 0.0_JPRB
  PTS        (:,JBLK)            = 0.0_JPRB
  PDECRD     (:,JBLK)            = 0.0_JPRB
  PCLCT      (:,JBLK)            = 0.0_JPRB
  PGDEOSI    (:,:,:,JBLK)        = 0.0_JPRB
  PGUEOSI    (:,:,:,JBLK)        = 0.0_JPRB
  PGMU0      (:,:,JBLK)          = 0.0_JPRB
  PGMU0_MIN  (:,JBLK)            = 0.0_JPRB
  PGMU0_MAX  (:,JBLK)            = 0.0_JPRB
  PGDEOTI    (:,:,JBLK)          = 0.0_JPRB
  PGDEOTI2   (:,:,JBLK)          = 0.0_JPRB
  PGUEOTI    (:,:,JBLK)          = 0.0_JPRB
  PGUEOTI2   (:,:,JBLK)          = 0.0_JPRB
  PGEOLT     (:,:,JBLK)          = 0.0_JPRB
  PGEOXT     (:,:,JBLK)          = 0.0_JPRB
  PGRPROX    (:,:,JBLK)          = 0.0_JPRB
  PGMIXP     (:,:,JBLK)          = 0.0_JPRB
  PGFLUXC    (:,:,JBLK)          = 0.0_JPRB
  PGRSURF    (:,JBLK)            = 0.0_JPRB
  PSDUR      (:,JBLK)            = 0.0_JPRB
  PFRSO      (:,:,JBLK)          = 0.0_JPRB
  PFRTH      (:,:,JBLK)          = 0.0_JPRB
  PFRSODS    (:,JBLK)            = 0.0_JPRB
  PFRSOPS    (:,JBLK)            = 0.0_JPRB
  PFRSOLU    (:,JBLK)            = 0.0_JPRB
  PFRTHDS    (:,JBLK)            = 0.0_JPRB
  PDAER      (:,:,:,JBLK)        = 0.0_JPRB
ENDDO

!$OMP END PARALLEL 
#endif

ENDIF


CALL PREPARE_ACRANEB2(YDERDI,YDRIP,YDML_PHY_MF,KIDIA,KFDIA,KLON,KTDIA,KLEV,KJN,KSTEP, &
 & KGPBLK, &
 & PAPRS,PAPRSF,PCP,PR,PDELP,PNEB,PQ,PQCO2,PQICE,PQLI,PQO3,PT, &
 & PALB,PALBDIR,PEMIS,PGELAM,PGEMU,PMU0,PMU0LU,PTS,PDECRD,PCLCT, &
 & PGDEOSI,PGUEOSI,PGMU0,PGMU0_MIN,PGMU0_MAX, &
 & PGDEOTI,PGDEOTI2,PGUEOTI,PGUEOTI2,PGEOLT,PGEOXT, &
 & PGRPROX,PGMIXP,PGFLUXC,PGRSURF,PSDUR, &
 & PFRSO,PFRTH, &
 & PFRSODS,PFRSOPS,PFRSOLU,PFRTHDS, &
 & PDAER)

ISTSZ = 51000*KLON
ALLOCATE (PSTACK (ISTSZ, KGPBLK))

ts=omp_get_wtime()

!$acc parallel loop gang vector private (JLON,JBLK) collapse (2)
DO JBLK=1, 1
  DO JLON = 1, 32
  CALL ACRANEB2(JLON,JLON,32,1,87)
  ENDDO
ENDDO
!$acc end parallel loop

END SUBROUTINE WRAPPER

END MODULE WRAPPER_MOD
